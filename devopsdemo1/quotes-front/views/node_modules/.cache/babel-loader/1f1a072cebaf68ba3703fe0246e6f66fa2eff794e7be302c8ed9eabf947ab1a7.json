{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nvar _excluded = [\"contentContainerStyle\", \"horizontal\", \"onContentSizeChange\", \"refreshControl\", \"stickyHeaderIndices\", \"pagingEnabled\", \"forwardedRef\", \"keyboardDismissMode\", \"onScroll\", \"centerContent\"];\n/**\n * Copyright (c) Nicolas Gallagher.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport Dimensions from '../Dimensions';\nimport dismissKeyboard from '../../modules/dismissKeyboard';\nimport invariant from 'fbjs/lib/invariant';\nimport mergeRefs from '../../modules/mergeRefs';\nimport Platform from '../Platform';\nimport ScrollViewBase from './ScrollViewBase';\nimport StyleSheet from '../StyleSheet';\nimport TextInputState from '../../modules/TextInputState';\nimport UIManager from '../UIManager';\nimport View from '../View';\nimport React from 'react';\nimport warning from 'fbjs/lib/warning';\nvar emptyObject = {};\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\nclass ScrollView extends React.Component {\n  constructor() {\n    super(...arguments);\n    this._scrollNodeRef = null;\n    this._innerViewRef = null;\n    this.isTouching = false;\n    this.lastMomentumScrollBeginTime = 0;\n    this.lastMomentumScrollEndTime = 0;\n    this.observedScrollSinceBecomingResponder = false;\n    this.becameResponderWhileAnimating = false;\n    this.scrollResponderHandleScrollShouldSetResponder = () => {\n      return this.isTouching;\n    };\n    this.scrollResponderHandleStartShouldSetResponderCapture = e => {\n      // First see if we want to eat taps while the keyboard is up\n      // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n      // if (!this.props.keyboardShouldPersistTaps &&\n      //   currentlyFocusedTextInput != null &&\n      //   e.target !== currentlyFocusedTextInput) {\n      //   return true;\n      // }\n      return this.scrollResponderIsAnimating();\n    };\n    this.scrollResponderHandleTerminationRequest = () => {\n      return !this.observedScrollSinceBecomingResponder;\n    };\n    this.scrollResponderHandleTouchEnd = e => {\n      var nativeEvent = e.nativeEvent;\n      this.isTouching = nativeEvent.touches.length !== 0;\n      this.props.onTouchEnd && this.props.onTouchEnd(e);\n    };\n    this.scrollResponderHandleResponderRelease = e => {\n      this.props.onResponderRelease && this.props.onResponderRelease(e);\n\n      // By default scroll views will unfocus a textField\n      // if another touch occurs outside of it\n      var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n      if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.observedScrollSinceBecomingResponder && !this.becameResponderWhileAnimating) {\n        this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);\n        TextInputState.blurTextInput(currentlyFocusedTextInput);\n      }\n    };\n    this.scrollResponderHandleScroll = e => {\n      this.observedScrollSinceBecomingResponder = true;\n      this.props.onScroll && this.props.onScroll(e);\n    };\n    this.scrollResponderHandleResponderGrant = e => {\n      this.observedScrollSinceBecomingResponder = false;\n      this.props.onResponderGrant && this.props.onResponderGrant(e);\n      this.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n    };\n    this.scrollResponderHandleScrollBeginDrag = e => {\n      this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n    };\n    this.scrollResponderHandleScrollEndDrag = e => {\n      this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n    };\n    this.scrollResponderHandleMomentumScrollBegin = e => {\n      this.lastMomentumScrollBeginTime = Date.now();\n      this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n    };\n    this.scrollResponderHandleMomentumScrollEnd = e => {\n      this.lastMomentumScrollEndTime = Date.now();\n      this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n    };\n    this.scrollResponderHandleTouchStart = e => {\n      this.isTouching = true;\n      this.props.onTouchStart && this.props.onTouchStart(e);\n    };\n    this.scrollResponderHandleTouchMove = e => {\n      this.props.onTouchMove && this.props.onTouchMove(e);\n    };\n    this.scrollResponderIsAnimating = () => {\n      var now = Date.now();\n      var timeSinceLastMomentumScrollEnd = now - this.lastMomentumScrollEndTime;\n      var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.lastMomentumScrollEndTime < this.lastMomentumScrollBeginTime;\n      return isAnimating;\n    };\n    this.scrollResponderScrollTo = (x, y, animated) => {\n      if (typeof x === 'number') {\n        console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\n      } else {\n        var _ref = x || emptyObject;\n        x = _ref.x;\n        y = _ref.y;\n        animated = _ref.animated;\n      }\n      var node = this.getScrollableNode();\n      var left = x || 0;\n      var top = y || 0;\n      if (node != null) {\n        if (typeof node.scroll === 'function') {\n          node.scroll({\n            top,\n            left,\n            behavior: !animated ? 'auto' : 'smooth'\n          });\n        } else {\n          node.scrollLeft = left;\n          node.scrollTop = top;\n        }\n      }\n    };\n    this.scrollResponderZoomTo = (rect, animated) => {\n      if (Platform.OS !== 'ios') {\n        invariant('zoomToRect is not implemented');\n      }\n    };\n    this.scrollResponderScrollNativeHandleToKeyboard = (nodeHandle, additionalOffset, preventNegativeScrollOffset) => {\n      this.additionalScrollOffset = additionalOffset || 0;\n      this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n      UIManager.measureLayout(nodeHandle, this.getInnerViewNode(), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);\n    };\n    this.scrollResponderInputMeasureAndScrollToKeyboard = (left, top, width, height) => {\n      var keyboardScreenY = Dimensions.get('window').height;\n      if (this.keyboardWillOpenTo) {\n        keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n      }\n      var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;\n\n      // By default, this can scroll with negative offset, pulling the content\n      // down so that the target component's bottom meets the keyboard's top.\n      // If requested otherwise, cap the offset at 0 minimum to avoid content\n      // shifting down.\n      if (this.preventNegativeScrollOffset) {\n        scrollOffsetY = Math.max(0, scrollOffsetY);\n      }\n      this.scrollResponderScrollTo({\n        x: 0,\n        y: scrollOffsetY,\n        animated: true\n      });\n      this.additionalOffset = 0;\n      this.preventNegativeScrollOffset = false;\n    };\n    this.scrollResponderKeyboardWillShow = e => {\n      this.keyboardWillOpenTo = e;\n      this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n    };\n    this.scrollResponderKeyboardWillHide = e => {\n      this.keyboardWillOpenTo = null;\n      this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n    };\n    this.scrollResponderKeyboardDidShow = e => {\n      // TODO(7693961): The event for DidShow is not available on iOS yet.\n      // Use the one from WillShow and do not assign.\n      if (e) {\n        this.keyboardWillOpenTo = e;\n      }\n      this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n    };\n    this.scrollResponderKeyboardDidHide = e => {\n      this.keyboardWillOpenTo = null;\n      this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n    };\n    this.flashScrollIndicators = () => {\n      this.scrollResponderFlashScrollIndicators();\n    };\n    this.getScrollResponder = () => {\n      return this;\n    };\n    this.getScrollableNode = () => {\n      return this._scrollNodeRef;\n    };\n    this.getInnerViewRef = () => {\n      return this._innerViewRef;\n    };\n    this.getInnerViewNode = () => {\n      return this._innerViewRef;\n    };\n    this.getNativeScrollRef = () => {\n      return this._scrollNodeRef;\n    };\n    this.scrollTo = (y, x, animated) => {\n      if (typeof y === 'number') {\n        console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.');\n      } else {\n        var _ref2 = y || emptyObject;\n        x = _ref2.x;\n        y = _ref2.y;\n        animated = _ref2.animated;\n      }\n      this.scrollResponderScrollTo({\n        x: x || 0,\n        y: y || 0,\n        animated: animated !== false\n      });\n    };\n    this.scrollToEnd = options => {\n      // Default to true\n      var animated = (options && options.animated) !== false;\n      var horizontal = this.props.horizontal;\n      var scrollResponderNode = this.getScrollableNode();\n      var x = horizontal ? scrollResponderNode.scrollWidth : 0;\n      var y = horizontal ? 0 : scrollResponderNode.scrollHeight;\n      this.scrollResponderScrollTo({\n        x,\n        y,\n        animated\n      });\n    };\n    this._handleContentOnLayout = e => {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n        width = _e$nativeEvent$layout.width,\n        height = _e$nativeEvent$layout.height;\n      this.props.onContentSizeChange(width, height);\n    };\n    this._handleScroll = e => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this.props.onScroll && this.props.scrollEventThrottle == null) {\n          console.log('You specified `onScroll` on a <ScrollView> but not ' + '`scrollEventThrottle`. You will only receive one event. ' + 'Using `16` you get all the events but be aware that it may ' + \"cause frame drops, use a bigger number if you don't need as \" + 'much precision.');\n        }\n      }\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        dismissKeyboard();\n      }\n      this.scrollResponderHandleScroll(e);\n    };\n    this._setInnerViewRef = node => {\n      this._innerViewRef = node;\n    };\n    this._setScrollNodeRef = node => {\n      this._scrollNodeRef = node;\n      // ScrollView needs to add more methods to the hostNode in addition to those\n      // added by `usePlatformMethods`. This is temporarily until an API like\n      // `ScrollView.scrollTo(hostNode, { x, y })` is added to React Native.\n      if (node != null) {\n        node.getScrollResponder = this.getScrollResponder;\n        node.getInnerViewNode = this.getInnerViewNode;\n        node.getInnerViewRef = this.getInnerViewRef;\n        node.getNativeScrollRef = this.getNativeScrollRef;\n        node.getScrollableNode = this.getScrollableNode;\n        node.scrollTo = this.scrollTo;\n        node.scrollToEnd = this.scrollToEnd;\n        node.flashScrollIndicators = this.flashScrollIndicators;\n        node.scrollResponderZoomTo = this.scrollResponderZoomTo;\n        node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard;\n      }\n      var ref = mergeRefs(this.props.forwardedRef);\n      ref(node);\n    };\n  }\n  /**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\n  scrollResponderHandleStartShouldSetResponder() {\n    return false;\n  }\n\n  /**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not the focused input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\n\n  /**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\n  scrollResponderHandleResponderReject() {\n    warning(false, \"ScrollView doesn't take rejection well - scrolls anyway\");\n  }\n\n  /**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\n\n  /**\n   * Displays the scroll indicators momentarily.\n   */\n  scrollResponderFlashScrollIndicators() {}\n\n  /**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {any} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's top \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\n\n  scrollResponderTextInputFocusError(e) {\n    console.error('Error measuring text field: ', e);\n  }\n\n  /**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` providesModule callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\n\n  render() {\n    var _this$props = this.props,\n      contentContainerStyle = _this$props.contentContainerStyle,\n      horizontal = _this$props.horizontal,\n      onContentSizeChange = _this$props.onContentSizeChange,\n      refreshControl = _this$props.refreshControl,\n      stickyHeaderIndices = _this$props.stickyHeaderIndices,\n      pagingEnabled = _this$props.pagingEnabled,\n      forwardedRef = _this$props.forwardedRef,\n      keyboardDismissMode = _this$props.keyboardDismissMode,\n      onScroll = _this$props.onScroll,\n      centerContent = _this$props.centerContent,\n      other = _objectWithoutPropertiesLoose(_this$props, _excluded);\n    if (process.env.NODE_ENV !== 'production' && this.props.style) {\n      var style = StyleSheet.flatten(this.props.style);\n      var childLayoutProps = ['alignItems', 'justifyContent'].filter(prop => style && style[prop] !== undefined);\n      invariant(childLayoutProps.length === 0, \"ScrollView child layout (\" + JSON.stringify(childLayoutProps) + \") \" + 'must be applied through the contentContainerStyle prop.');\n    }\n    var contentSizeChangeProps = {};\n    if (onContentSizeChange) {\n      contentSizeChangeProps = {\n        onLayout: this._handleContentOnLayout\n      };\n    }\n    var hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices);\n    var children = hasStickyHeaderIndices || pagingEnabled ? React.Children.map(this.props.children, (child, i) => {\n      var isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;\n      if (child != null && (isSticky || pagingEnabled)) {\n        return /*#__PURE__*/React.createElement(View, {\n          style: [isSticky && styles.stickyHeader, pagingEnabled && styles.pagingEnabledChild]\n        }, child);\n      } else {\n        return child;\n      }\n    }) : this.props.children;\n    var contentContainer = /*#__PURE__*/React.createElement(View, _extends({}, contentSizeChangeProps, {\n      children: children,\n      collapsable: false,\n      ref: this._setInnerViewRef,\n      style: [horizontal && styles.contentContainerHorizontal, centerContent && styles.contentContainerCenterContent, contentContainerStyle]\n    }));\n    var baseStyle = horizontal ? styles.baseHorizontal : styles.baseVertical;\n    var pagingEnabledStyle = horizontal ? styles.pagingEnabledHorizontal : styles.pagingEnabledVertical;\n    var props = _objectSpread(_objectSpread({}, other), {}, {\n      style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],\n      onTouchStart: this.scrollResponderHandleTouchStart,\n      onTouchMove: this.scrollResponderHandleTouchMove,\n      onTouchEnd: this.scrollResponderHandleTouchEnd,\n      onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,\n      onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,\n      onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,\n      onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,\n      onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,\n      onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,\n      onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,\n      onScroll: this._handleScroll,\n      onResponderGrant: this.scrollResponderHandleResponderGrant,\n      onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,\n      onResponderTerminate: this.scrollResponderHandleTerminate,\n      onResponderRelease: this.scrollResponderHandleResponderRelease,\n      onResponderReject: this.scrollResponderHandleResponderReject\n    });\n    var ScrollViewClass = ScrollViewBase;\n    invariant(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');\n    var scrollView = /*#__PURE__*/React.createElement(ScrollViewClass, _extends({}, props, {\n      ref: this._setScrollNodeRef\n    }), contentContainer);\n    if (refreshControl) {\n      return /*#__PURE__*/React.cloneElement(refreshControl, {\n        style: props.style\n      }, scrollView);\n    }\n    return scrollView;\n  }\n}\nvar commonStyle = {\n  flexGrow: 1,\n  flexShrink: 1,\n  // Enable hardware compositing in modern browsers.\n  // Creates a new layer with its own backing surface that can significantly\n  // improve scroll performance.\n  transform: 'translateZ(0)',\n  // iOS native scrolling\n  WebkitOverflowScrolling: 'touch'\n};\nvar styles = StyleSheet.create({\n  baseVertical: _objectSpread(_objectSpread({}, commonStyle), {}, {\n    flexDirection: 'column',\n    overflowX: 'hidden',\n    overflowY: 'auto'\n  }),\n  baseHorizontal: _objectSpread(_objectSpread({}, commonStyle), {}, {\n    flexDirection: 'row',\n    overflowX: 'auto',\n    overflowY: 'hidden'\n  }),\n  contentContainerHorizontal: {\n    flexDirection: 'row'\n  },\n  contentContainerCenterContent: {\n    justifyContent: 'center',\n    flexGrow: 1\n  },\n  stickyHeader: {\n    position: 'sticky',\n    top: 0,\n    zIndex: 10\n  },\n  pagingEnabledHorizontal: {\n    scrollSnapType: 'x mandatory'\n  },\n  pagingEnabledVertical: {\n    scrollSnapType: 'y mandatory'\n  },\n  pagingEnabledChild: {\n    scrollSnapAlign: 'start'\n  }\n});\nvar ForwardedScrollView = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {\n  return /*#__PURE__*/React.createElement(ScrollView, _extends({}, props, {\n    forwardedRef: forwardedRef\n  }));\n});\nForwardedScrollView.displayName = 'ScrollView';\nexport default ForwardedScrollView;","map":{"version":3,"names":["_objectSpread","_extends","_objectWithoutPropertiesLoose","_excluded","Dimensions","dismissKeyboard","invariant","mergeRefs","Platform","ScrollViewBase","StyleSheet","TextInputState","UIManager","View","React","warning","emptyObject","IS_ANIMATING_TOUCH_START_THRESHOLD_MS","ScrollView","Component","constructor","arguments","_scrollNodeRef","_innerViewRef","isTouching","lastMomentumScrollBeginTime","lastMomentumScrollEndTime","observedScrollSinceBecomingResponder","becameResponderWhileAnimating","scrollResponderHandleScrollShouldSetResponder","scrollResponderHandleStartShouldSetResponderCapture","e","scrollResponderIsAnimating","scrollResponderHandleTerminationRequest","scrollResponderHandleTouchEnd","nativeEvent","touches","length","props","onTouchEnd","scrollResponderHandleResponderRelease","onResponderRelease","currentlyFocusedTextInput","currentlyFocusedField","keyboardShouldPersistTaps","target","onScrollResponderKeyboardDismissed","blurTextInput","scrollResponderHandleScroll","onScroll","scrollResponderHandleResponderGrant","onResponderGrant","scrollResponderHandleScrollBeginDrag","onScrollBeginDrag","scrollResponderHandleScrollEndDrag","onScrollEndDrag","scrollResponderHandleMomentumScrollBegin","Date","now","onMomentumScrollBegin","scrollResponderHandleMomentumScrollEnd","onMomentumScrollEnd","scrollResponderHandleTouchStart","onTouchStart","scrollResponderHandleTouchMove","onTouchMove","timeSinceLastMomentumScrollEnd","isAnimating","scrollResponderScrollTo","x","y","animated","console","warn","_ref","node","getScrollableNode","left","top","scroll","behavior","scrollLeft","scrollTop","scrollResponderZoomTo","rect","OS","scrollResponderScrollNativeHandleToKeyboard","nodeHandle","additionalOffset","preventNegativeScrollOffset","additionalScrollOffset","measureLayout","getInnerViewNode","scrollResponderTextInputFocusError","scrollResponderInputMeasureAndScrollToKeyboard","width","height","keyboardScreenY","get","keyboardWillOpenTo","endCoordinates","screenY","scrollOffsetY","Math","max","scrollResponderKeyboardWillShow","onKeyboardWillShow","scrollResponderKeyboardWillHide","onKeyboardWillHide","scrollResponderKeyboardDidShow","onKeyboardDidShow","scrollResponderKeyboardDidHide","onKeyboardDidHide","flashScrollIndicators","scrollResponderFlashScrollIndicators","getScrollResponder","getInnerViewRef","getNativeScrollRef","scrollTo","_ref2","scrollToEnd","options","horizontal","scrollResponderNode","scrollWidth","scrollHeight","_handleContentOnLayout","_e$nativeEvent$layout","layout","onContentSizeChange","_handleScroll","process","env","NODE_ENV","scrollEventThrottle","log","keyboardDismissMode","_setInnerViewRef","_setScrollNodeRef","ref","forwardedRef","scrollResponderHandleStartShouldSetResponder","scrollResponderHandleResponderReject","error","render","_this$props","contentContainerStyle","refreshControl","stickyHeaderIndices","pagingEnabled","centerContent","other","style","flatten","childLayoutProps","filter","prop","undefined","JSON","stringify","contentSizeChangeProps","onLayout","hasStickyHeaderIndices","Array","isArray","children","Children","map","child","i","isSticky","indexOf","createElement","styles","stickyHeader","pagingEnabledChild","contentContainer","collapsable","contentContainerHorizontal","contentContainerCenterContent","baseStyle","baseHorizontal","baseVertical","pagingEnabledStyle","pagingEnabledHorizontal","pagingEnabledVertical","onStartShouldSetResponder","onStartShouldSetResponderCapture","onScrollShouldSetResponder","onResponderTerminationRequest","onResponderTerminate","scrollResponderHandleTerminate","onResponderReject","ScrollViewClass","scrollView","cloneElement","commonStyle","flexGrow","flexShrink","transform","WebkitOverflowScrolling","create","flexDirection","overflowX","overflowY","justifyContent","position","zIndex","scrollSnapType","scrollSnapAlign","ForwardedScrollView","forwardRef","displayName"],"sources":["/home/user/gcpdemos/devopsdemo1/quotes-front/views/node_modules/react-native-web/dist/exports/ScrollView/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nvar _excluded = [\"contentContainerStyle\", \"horizontal\", \"onContentSizeChange\", \"refreshControl\", \"stickyHeaderIndices\", \"pagingEnabled\", \"forwardedRef\", \"keyboardDismissMode\", \"onScroll\", \"centerContent\"];\n/**\n * Copyright (c) Nicolas Gallagher.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport Dimensions from '../Dimensions';\nimport dismissKeyboard from '../../modules/dismissKeyboard';\nimport invariant from 'fbjs/lib/invariant';\nimport mergeRefs from '../../modules/mergeRefs';\nimport Platform from '../Platform';\nimport ScrollViewBase from './ScrollViewBase';\nimport StyleSheet from '../StyleSheet';\nimport TextInputState from '../../modules/TextInputState';\nimport UIManager from '../UIManager';\nimport View from '../View';\nimport React from 'react';\nimport warning from 'fbjs/lib/warning';\nvar emptyObject = {};\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\nclass ScrollView extends React.Component {\n  constructor() {\n    super(...arguments);\n    this._scrollNodeRef = null;\n    this._innerViewRef = null;\n    this.isTouching = false;\n    this.lastMomentumScrollBeginTime = 0;\n    this.lastMomentumScrollEndTime = 0;\n    this.observedScrollSinceBecomingResponder = false;\n    this.becameResponderWhileAnimating = false;\n    this.scrollResponderHandleScrollShouldSetResponder = () => {\n      return this.isTouching;\n    };\n    this.scrollResponderHandleStartShouldSetResponderCapture = e => {\n      // First see if we want to eat taps while the keyboard is up\n      // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n      // if (!this.props.keyboardShouldPersistTaps &&\n      //   currentlyFocusedTextInput != null &&\n      //   e.target !== currentlyFocusedTextInput) {\n      //   return true;\n      // }\n      return this.scrollResponderIsAnimating();\n    };\n    this.scrollResponderHandleTerminationRequest = () => {\n      return !this.observedScrollSinceBecomingResponder;\n    };\n    this.scrollResponderHandleTouchEnd = e => {\n      var nativeEvent = e.nativeEvent;\n      this.isTouching = nativeEvent.touches.length !== 0;\n      this.props.onTouchEnd && this.props.onTouchEnd(e);\n    };\n    this.scrollResponderHandleResponderRelease = e => {\n      this.props.onResponderRelease && this.props.onResponderRelease(e);\n\n      // By default scroll views will unfocus a textField\n      // if another touch occurs outside of it\n      var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n      if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.observedScrollSinceBecomingResponder && !this.becameResponderWhileAnimating) {\n        this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);\n        TextInputState.blurTextInput(currentlyFocusedTextInput);\n      }\n    };\n    this.scrollResponderHandleScroll = e => {\n      this.observedScrollSinceBecomingResponder = true;\n      this.props.onScroll && this.props.onScroll(e);\n    };\n    this.scrollResponderHandleResponderGrant = e => {\n      this.observedScrollSinceBecomingResponder = false;\n      this.props.onResponderGrant && this.props.onResponderGrant(e);\n      this.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n    };\n    this.scrollResponderHandleScrollBeginDrag = e => {\n      this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n    };\n    this.scrollResponderHandleScrollEndDrag = e => {\n      this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n    };\n    this.scrollResponderHandleMomentumScrollBegin = e => {\n      this.lastMomentumScrollBeginTime = Date.now();\n      this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n    };\n    this.scrollResponderHandleMomentumScrollEnd = e => {\n      this.lastMomentumScrollEndTime = Date.now();\n      this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n    };\n    this.scrollResponderHandleTouchStart = e => {\n      this.isTouching = true;\n      this.props.onTouchStart && this.props.onTouchStart(e);\n    };\n    this.scrollResponderHandleTouchMove = e => {\n      this.props.onTouchMove && this.props.onTouchMove(e);\n    };\n    this.scrollResponderIsAnimating = () => {\n      var now = Date.now();\n      var timeSinceLastMomentumScrollEnd = now - this.lastMomentumScrollEndTime;\n      var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.lastMomentumScrollEndTime < this.lastMomentumScrollBeginTime;\n      return isAnimating;\n    };\n    this.scrollResponderScrollTo = (x, y, animated) => {\n      if (typeof x === 'number') {\n        console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\n      } else {\n        var _ref = x || emptyObject;\n        x = _ref.x;\n        y = _ref.y;\n        animated = _ref.animated;\n      }\n      var node = this.getScrollableNode();\n      var left = x || 0;\n      var top = y || 0;\n      if (node != null) {\n        if (typeof node.scroll === 'function') {\n          node.scroll({\n            top,\n            left,\n            behavior: !animated ? 'auto' : 'smooth'\n          });\n        } else {\n          node.scrollLeft = left;\n          node.scrollTop = top;\n        }\n      }\n    };\n    this.scrollResponderZoomTo = (rect, animated) => {\n      if (Platform.OS !== 'ios') {\n        invariant('zoomToRect is not implemented');\n      }\n    };\n    this.scrollResponderScrollNativeHandleToKeyboard = (nodeHandle, additionalOffset, preventNegativeScrollOffset) => {\n      this.additionalScrollOffset = additionalOffset || 0;\n      this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n      UIManager.measureLayout(nodeHandle, this.getInnerViewNode(), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);\n    };\n    this.scrollResponderInputMeasureAndScrollToKeyboard = (left, top, width, height) => {\n      var keyboardScreenY = Dimensions.get('window').height;\n      if (this.keyboardWillOpenTo) {\n        keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n      }\n      var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;\n\n      // By default, this can scroll with negative offset, pulling the content\n      // down so that the target component's bottom meets the keyboard's top.\n      // If requested otherwise, cap the offset at 0 minimum to avoid content\n      // shifting down.\n      if (this.preventNegativeScrollOffset) {\n        scrollOffsetY = Math.max(0, scrollOffsetY);\n      }\n      this.scrollResponderScrollTo({\n        x: 0,\n        y: scrollOffsetY,\n        animated: true\n      });\n      this.additionalOffset = 0;\n      this.preventNegativeScrollOffset = false;\n    };\n    this.scrollResponderKeyboardWillShow = e => {\n      this.keyboardWillOpenTo = e;\n      this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n    };\n    this.scrollResponderKeyboardWillHide = e => {\n      this.keyboardWillOpenTo = null;\n      this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n    };\n    this.scrollResponderKeyboardDidShow = e => {\n      // TODO(7693961): The event for DidShow is not available on iOS yet.\n      // Use the one from WillShow and do not assign.\n      if (e) {\n        this.keyboardWillOpenTo = e;\n      }\n      this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n    };\n    this.scrollResponderKeyboardDidHide = e => {\n      this.keyboardWillOpenTo = null;\n      this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n    };\n    this.flashScrollIndicators = () => {\n      this.scrollResponderFlashScrollIndicators();\n    };\n    this.getScrollResponder = () => {\n      return this;\n    };\n    this.getScrollableNode = () => {\n      return this._scrollNodeRef;\n    };\n    this.getInnerViewRef = () => {\n      return this._innerViewRef;\n    };\n    this.getInnerViewNode = () => {\n      return this._innerViewRef;\n    };\n    this.getNativeScrollRef = () => {\n      return this._scrollNodeRef;\n    };\n    this.scrollTo = (y, x, animated) => {\n      if (typeof y === 'number') {\n        console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.');\n      } else {\n        var _ref2 = y || emptyObject;\n        x = _ref2.x;\n        y = _ref2.y;\n        animated = _ref2.animated;\n      }\n      this.scrollResponderScrollTo({\n        x: x || 0,\n        y: y || 0,\n        animated: animated !== false\n      });\n    };\n    this.scrollToEnd = options => {\n      // Default to true\n      var animated = (options && options.animated) !== false;\n      var horizontal = this.props.horizontal;\n      var scrollResponderNode = this.getScrollableNode();\n      var x = horizontal ? scrollResponderNode.scrollWidth : 0;\n      var y = horizontal ? 0 : scrollResponderNode.scrollHeight;\n      this.scrollResponderScrollTo({\n        x,\n        y,\n        animated\n      });\n    };\n    this._handleContentOnLayout = e => {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n        width = _e$nativeEvent$layout.width,\n        height = _e$nativeEvent$layout.height;\n      this.props.onContentSizeChange(width, height);\n    };\n    this._handleScroll = e => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this.props.onScroll && this.props.scrollEventThrottle == null) {\n          console.log('You specified `onScroll` on a <ScrollView> but not ' + '`scrollEventThrottle`. You will only receive one event. ' + 'Using `16` you get all the events but be aware that it may ' + \"cause frame drops, use a bigger number if you don't need as \" + 'much precision.');\n        }\n      }\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        dismissKeyboard();\n      }\n      this.scrollResponderHandleScroll(e);\n    };\n    this._setInnerViewRef = node => {\n      this._innerViewRef = node;\n    };\n    this._setScrollNodeRef = node => {\n      this._scrollNodeRef = node;\n      // ScrollView needs to add more methods to the hostNode in addition to those\n      // added by `usePlatformMethods`. This is temporarily until an API like\n      // `ScrollView.scrollTo(hostNode, { x, y })` is added to React Native.\n      if (node != null) {\n        node.getScrollResponder = this.getScrollResponder;\n        node.getInnerViewNode = this.getInnerViewNode;\n        node.getInnerViewRef = this.getInnerViewRef;\n        node.getNativeScrollRef = this.getNativeScrollRef;\n        node.getScrollableNode = this.getScrollableNode;\n        node.scrollTo = this.scrollTo;\n        node.scrollToEnd = this.scrollToEnd;\n        node.flashScrollIndicators = this.flashScrollIndicators;\n        node.scrollResponderZoomTo = this.scrollResponderZoomTo;\n        node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard;\n      }\n      var ref = mergeRefs(this.props.forwardedRef);\n      ref(node);\n    };\n  }\n  /**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\n  scrollResponderHandleStartShouldSetResponder() {\n    return false;\n  }\n\n  /**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not the focused input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\n\n  /**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\n  scrollResponderHandleResponderReject() {\n    warning(false, \"ScrollView doesn't take rejection well - scrolls anyway\");\n  }\n\n  /**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\n\n  /**\n   * Displays the scroll indicators momentarily.\n   */\n  scrollResponderFlashScrollIndicators() {}\n\n  /**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {any} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's top \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\n\n  scrollResponderTextInputFocusError(e) {\n    console.error('Error measuring text field: ', e);\n  }\n\n  /**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` providesModule callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\n\n  render() {\n    var _this$props = this.props,\n      contentContainerStyle = _this$props.contentContainerStyle,\n      horizontal = _this$props.horizontal,\n      onContentSizeChange = _this$props.onContentSizeChange,\n      refreshControl = _this$props.refreshControl,\n      stickyHeaderIndices = _this$props.stickyHeaderIndices,\n      pagingEnabled = _this$props.pagingEnabled,\n      forwardedRef = _this$props.forwardedRef,\n      keyboardDismissMode = _this$props.keyboardDismissMode,\n      onScroll = _this$props.onScroll,\n      centerContent = _this$props.centerContent,\n      other = _objectWithoutPropertiesLoose(_this$props, _excluded);\n    if (process.env.NODE_ENV !== 'production' && this.props.style) {\n      var style = StyleSheet.flatten(this.props.style);\n      var childLayoutProps = ['alignItems', 'justifyContent'].filter(prop => style && style[prop] !== undefined);\n      invariant(childLayoutProps.length === 0, \"ScrollView child layout (\" + JSON.stringify(childLayoutProps) + \") \" + 'must be applied through the contentContainerStyle prop.');\n    }\n    var contentSizeChangeProps = {};\n    if (onContentSizeChange) {\n      contentSizeChangeProps = {\n        onLayout: this._handleContentOnLayout\n      };\n    }\n    var hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices);\n    var children = hasStickyHeaderIndices || pagingEnabled ? React.Children.map(this.props.children, (child, i) => {\n      var isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;\n      if (child != null && (isSticky || pagingEnabled)) {\n        return /*#__PURE__*/React.createElement(View, {\n          style: [isSticky && styles.stickyHeader, pagingEnabled && styles.pagingEnabledChild]\n        }, child);\n      } else {\n        return child;\n      }\n    }) : this.props.children;\n    var contentContainer = /*#__PURE__*/React.createElement(View, _extends({}, contentSizeChangeProps, {\n      children: children,\n      collapsable: false,\n      ref: this._setInnerViewRef,\n      style: [horizontal && styles.contentContainerHorizontal, centerContent && styles.contentContainerCenterContent, contentContainerStyle]\n    }));\n    var baseStyle = horizontal ? styles.baseHorizontal : styles.baseVertical;\n    var pagingEnabledStyle = horizontal ? styles.pagingEnabledHorizontal : styles.pagingEnabledVertical;\n    var props = _objectSpread(_objectSpread({}, other), {}, {\n      style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],\n      onTouchStart: this.scrollResponderHandleTouchStart,\n      onTouchMove: this.scrollResponderHandleTouchMove,\n      onTouchEnd: this.scrollResponderHandleTouchEnd,\n      onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,\n      onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,\n      onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,\n      onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,\n      onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,\n      onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,\n      onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,\n      onScroll: this._handleScroll,\n      onResponderGrant: this.scrollResponderHandleResponderGrant,\n      onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,\n      onResponderTerminate: this.scrollResponderHandleTerminate,\n      onResponderRelease: this.scrollResponderHandleResponderRelease,\n      onResponderReject: this.scrollResponderHandleResponderReject\n    });\n    var ScrollViewClass = ScrollViewBase;\n    invariant(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');\n    var scrollView = /*#__PURE__*/React.createElement(ScrollViewClass, _extends({}, props, {\n      ref: this._setScrollNodeRef\n    }), contentContainer);\n    if (refreshControl) {\n      return /*#__PURE__*/React.cloneElement(refreshControl, {\n        style: props.style\n      }, scrollView);\n    }\n    return scrollView;\n  }\n}\nvar commonStyle = {\n  flexGrow: 1,\n  flexShrink: 1,\n  // Enable hardware compositing in modern browsers.\n  // Creates a new layer with its own backing surface that can significantly\n  // improve scroll performance.\n  transform: 'translateZ(0)',\n  // iOS native scrolling\n  WebkitOverflowScrolling: 'touch'\n};\nvar styles = StyleSheet.create({\n  baseVertical: _objectSpread(_objectSpread({}, commonStyle), {}, {\n    flexDirection: 'column',\n    overflowX: 'hidden',\n    overflowY: 'auto'\n  }),\n  baseHorizontal: _objectSpread(_objectSpread({}, commonStyle), {}, {\n    flexDirection: 'row',\n    overflowX: 'auto',\n    overflowY: 'hidden'\n  }),\n  contentContainerHorizontal: {\n    flexDirection: 'row'\n  },\n  contentContainerCenterContent: {\n    justifyContent: 'center',\n    flexGrow: 1\n  },\n  stickyHeader: {\n    position: 'sticky',\n    top: 0,\n    zIndex: 10\n  },\n  pagingEnabledHorizontal: {\n    scrollSnapType: 'x mandatory'\n  },\n  pagingEnabledVertical: {\n    scrollSnapType: 'y mandatory'\n  },\n  pagingEnabledChild: {\n    scrollSnapAlign: 'start'\n  }\n});\nvar ForwardedScrollView = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {\n  return /*#__PURE__*/React.createElement(ScrollView, _extends({}, props, {\n    forwardedRef: forwardedRef\n  }));\n});\nForwardedScrollView.displayName = 'ScrollView';\nexport default ForwardedScrollView;"],"mappings":"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,gBAAgB;QAC7CjB,IAAI,CAACyC,eAAe,GAAG,IAAI,CAACA,eAAe;QAC3CzC,IAAI,CAAC0C,kBAAkB,GAAG,IAAI,CAACA,kBAAkB;QACjD1C,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACA,iBAAiB;QAC/CD,IAAI,CAAC2C,QAAQ,GAAG,IAAI,CAACA,QAAQ;QAC7B3C,IAAI,CAAC6C,WAAW,GAAG,IAAI,CAACA,WAAW;QACnC7C,IAAI,CAACsC,qBAAqB,GAAG,IAAI,CAACA,qBAAqB;QACvDtC,IAAI,CAACQ,qBAAqB,GAAG,IAAI,CAACA,qBAAqB;QACvDR,IAAI,CAACW,2CAA2C,GAAG,IAAI,CAACA,2CAA2C;MACrG;MACA,IAAIqD,GAAG,GAAGpI,SAAS,CAAC,IAAI,CAAC+B,KAAK,CAACsG,YAAY,CAAC;MAC5CD,GAAG,CAAChE,IAAI,CAAC;IACX,CAAC;EACH;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEkE,4CAA4CA,CAAA,EAAG;IAC7C,OAAO,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,oCAAoCA,CAAA,EAAG;IACrC/H,OAAO,CAAC,KAAK,EAAE,yDAAyD,CAAC;EAC3E;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;EACEmG,oCAAoCA,CAAA,EAAG,CAAC;;EAExC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEErB,kCAAkCA,CAAC9D,CAAC,EAAE;IACpCyC,OAAO,CAACuE,KAAK,CAAC,8BAA8B,EAAEhH,CAAC,CAAC;EAClD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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"},"metadata":{},"sourceType":"module","externalDependencies":[]}